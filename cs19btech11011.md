# Introduction
The report is about the different OOP concepts used in the LLVM/Clang code base. The chunks of code from code base have been included in the report along with their analysis.

# Examples
### C++ 11 features
```
using namespace llvm;		
static cl::opt<bool> Wave("wave-goodbye", cl::init(false),
cl::desc("wave good bye"));
```
The **cl** is defined inside the llvm namespace so it can be used directly even though it has not been defined earlier in that file. The scope resolution operator is used to access the members and methods inside **cl**.
```
assert(Add1F->arg_begin() != Add1F->arg_end()); // Make sure there's an arg
Argument *ArgX = &*Add1F->arg_begin(); // Get the arg
```
The assert function takes the boolean as argument which is generated by the comparison of the iterators of the list of arguments which is pointed by Add1F. So basically it makes sure there is some argument in list, which could also be done by wrapping this functionality inside a isEmpty function. Another important aspect to observe is the usage of &\* which actually cancel out each other which is a coding style decision they took to make it more readable.
```
Module *M = new  Module("test", Context);
```
A pointer to the instance of Module class is created by calling its constructor which takes another object Context as argument. 
```
enum class object_error {
arch_not_found = 1,
invalid_file_type
};

inline std::error_code make_error_code(object_error e) {
return std::error_code(static_cast<int>(e), object_category());
}
```
Two concepts of C++ have been used here. The enum class was used which gives the enumeration for the words beginning with 1. The inline keyword has been used to make sure that the function is replaced in the same line when it is called. 
```
class  RelocationRef {
friend  class  SymbolRef;
const ObjectFile *OwningObject = nullptr;
bool  operator==(const RelocationRef &Other) const;
};
```
The class SymbolRef is a friend to the class RelocationRef which means that all functionalities and members of SymbolRef can be used/modified by RelocationRef. The keyword const is used before the declaration and also at the end of function prototype which have two different meanings. The const at the start of the declaration implies that the value of the variable cannot be changed at later point and the const at the end of function prototype implies that the function does not modify state of object that calls it.
```
template<typename T>
class LLVM_GSL_POINTER LLVM_NODISCARD ArrayRef {
public:
using value_type = T;
using pointer = value_type *;
```
The template and typename are keywords which are used to define a generic class argument named value_type which could store any data type as per the declaration of the object.
### Class hierarchy
```
struct LegacyBye : public FunctionPass {
static char ID;
LegacyBye() : FunctionPass(ID) {}
bool runOnFunction(Function &F) override { return runBye(F); }
};
```
The struct LegacyBye has been inherited from the class FunctionPass publicly. This means that the protected and private data members and methods are not inherited by LegacyBye. The constructor also has been inherited and additional functionalities have been added. The function runOnFunction is virtual which means it has not been defined in the root ancestor class and was made to be a placeholder for the derived classes to override.
```
class AccelTableData {
public:
	virtual ~AccelTableData() = default;
protected:
	virtual uint64_t order() const = 0;
};

class  AppleAccelTableData : public  AccelTableData
class  DWARF5AccelTableData : public  AccelTableData
class  AppleAccelTableStaticOffsetData : public  AppleAccelTableData
class  AppleAccelTableStaticTypeData : public  AppleAccelTableStaticOffsetData
```
This is just a small snippet of code from the large AccelTable.h. We can observe that there is a tree formed from this inheritance which is called the class hierarchy. The AccelTableData is the parent (root) class which is has AppleAccelTableData and DWARF5AccelTableData as its derived classes. The AppleAccelTableData class is further inherited by AppleAccelTableStaticOffsetData which is inherited by AppleAccelTableStaticTypeData. There are many such trees and their hierarchies can be found [here](https://llvm.org/doxygen/hierarchy.html).

### Functional programming
```
auto I = find_if(Tbl, [=](const CostTblEntry &Entry) {
return ISD == Entry.ISD && Ty == Entry.Type;
});
```
The auto keyword is used to let the compiler find the data type of the value and assign the variable correspondingly. In this code, the I is a functional pointer and the special symbol [=] is a lambda capture list which is used to copy by value, the local variables needed for the lambda expression. Another symbol [&] can also be used which passes by reference.
### Design Decisions
```
//==-- llvm/FileCheck/FileCheck.h ----------------------------*- C++ -*-==//
/// \file This file has some utilities to use FileCheck as an API
#ifndef LLVM_FILECHECK_FILECHECK_H
#define LLVM_FILECHECK_FILECHECK_H
```
LLVM follows strict design and coding standards. The first line contains the -\*- C++ -\*- to indicate that it is a C++ file and also details about the code's use must be commented properly at the beginning. The macros must be in caps and separated by underscores. LLVM tries to use as minimal include as possible to improve compilation time and does not use braced initializers for constructor calls. It is advised to use auto for readability. More of the design decisions can be found [here](https://llvm.org/docs/CodingStandards.html).
### C++ 14 features
```
static constexpr Spelling S[] = {{ParsedAttr::AS_GNU, "example"},
								{ParsedAttr::AS_CXX11, "example"},
								{ParsedAttr::AS_CXX11, "plugin::example"}};
```
The constexpr is a new keyword which was used mostly from C++ 14. It is similar to const but can be used for classes or structures or arrays. It makes sure that the whole entity is remaining unchanged after its creation. The keyword static is used to make sure it is not re-initialized when we call the same line of code again.

