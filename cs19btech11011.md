# Introduction
The report is about the different OOP concepts used in the LLVM/Clang code base. The chunks of code from code base have been included in the report along with their analysis.

# Examples

### C++ 11/C++ 14 features
```
using namespace llvm;		
static cl::opt<bool> Wave("wave-goodbye", cl::init(false),
cl::desc("wave good bye"));
```
The **cl** is defined inside the llvm namespace so it can be used directly even though it has not been defined earlier in that file. The scope resolution operator is used to access the members and methods inside **cl**.
```
assert(Add1F->arg_begin() != Add1F->arg_end()); // Make sure there's an arg
Argument *ArgX = &*Add1F->arg_begin(); // Get the arg
```
The assert function takes the boolean as argument which is generated by the comparison of the iterators of the list of arguments which is pointed by Add1F. So basically it makes sure there is some argument in list, which could also be done by wrapping this functionality inside a isEmpty function. Another important aspect to observe is the usage of &\* which actually cancel out each other which is a coding style decision they took to make it more readable.
```
Module *M = new  Module("test", Context);
```
A pointer to the instance of Module class is created by calling its constructor which takes another object Context as argument. 
```
enum class object_error {
arch_not_found = 1,
invalid_file_type
};

inline std::error_code make_error_code(object_error e) {
return std::error_code(static_cast<int>(e), object_category());
}
```
Two concepts of C++ have been used here. The enum class was used which gives the enumeration for the words beginning with 1. The inline keyword has been used to make sure that the function is replaced in the same line when it is called. 
```
class  RelocationRef {
friend  class  SymbolRef;
const ObjectFile *OwningObject = nullptr;
bool  operator==(const RelocationRef &Other) const;
};
```
The class SymbolRef is a friend to the class RelocationRef which means that all functionalities and members of SymbolRef can be used/modified by RelocationRef. The keyword const is used before the declaration and also at the end of function prototype which have two different meanings. The const at the start of the declaration implies that the value of the variable cannot be changed at later point and the const at the end of function prototype implies that the function does not modify state of object that calls it. It can also be observed that == operator has been overloaded for the objects of this class.
```
template<typename T>
class LLVM_GSL_POINTER LLVM_NODISCARD ArrayRef {
public:
using value_type = T;
using pointer = value_type *;
```
The template and typename are keywords which are used to define a namespace member named value_type which could store any data type as per the declaration of the object. This makes the value_type generic.
```
static constexpr Spelling S[] = {{ParsedAttr::AS_GNU, "example"},
								{ParsedAttr::AS_CXX11, "example"},
								{ParsedAttr::AS_CXX11, "plugin::example"}};
```
The constexpr is a new keyword which was used mostly from C++ 14. It is similar to const but can be used for classes or structures or arrays. It makes sure that the whole entity is remaining unchanged after its creation. The keyword static is used to make sure it is not re-initialized when the same line of code is executed again.
```
constexpr InputKind(Language L = Language::Unknown, Format F = Source,bool PP = false)
	: Lang(L), Fmt(F), Preprocessed(PP) {}
```
This is a unique way of writing constructor with direct initialization of the variables by using the data members with variables corresponding to them in parentheses. We could give the default values in the definition itself in case they were not provided by the function call.

### Class hierarchy
```
struct LegacyBye : public FunctionPass {
static char ID;
LegacyBye() : FunctionPass(ID) {}
bool runOnFunction(Function &F) override { return runBye(F); }
};
```
The struct LegacyBye has been inherited from the class FunctionPass publicly. This means that the private data members and methods are not inherited by LegacyBye. The constructor also has been inherited and additional functionalities have been added. The function runOnFunction is virtual which means it has not been defined in the root ancestor class and was made to be a placeholder for the derived classes to override.
```
class AccelTableData {
public:
	virtual ~AccelTableData() = default;
protected:
	virtual uint64_t order() const = 0;
};

class  AppleAccelTableData : public  AccelTableData
class  DWARF5AccelTableData : public  AccelTableData
class  AppleAccelTableStaticOffsetData : public  AppleAccelTableData
class  AppleAccelTableStaticTypeData : public  AppleAccelTableStaticOffsetData
```
This is just a small snippet of code from the large AccelTable.h. We can observe that there is a tree formed from this inheritance which is called the class hierarchy. The AccelTableData is the parent (root) class which is has AppleAccelTableData and DWARF5AccelTableData as its derived classes. The AppleAccelTableData class is further inherited by AppleAccelTableStaticOffsetData which is inherited by AppleAccelTableStaticTypeData. There are many such trees and their hierarchies can be found [here](https://llvm.org/doxygen/hierarchy.html).

### Functional programming
```
auto I = find_if(Tbl, [=](const CostTblEntry &Entry) {
return ISD == Entry.ISD && Ty == Entry.Type;
});
```
The auto keyword is used to let the compiler find the data type of the value and assign the variable correspondingly. In this code, the I is a functional pointer and the special symbol [=] is a lambda capture list which is used to copy by value, the local variables needed for the lambda expression. Another symbol [&] can also be used which passes by reference.

### Design Decisions and Patterns
```
//==-- llvm/FileCheck/FileCheck.h ----------------------------*- C++ -*-==//
/// \file This file has some utilities to use FileCheck as an API
#ifndef LLVM_FILECHECK_FILECHECK_H
#define LLVM_FILECHECK_FILECHECK_H
```
LLVM follows strict design and coding standards. The first line contains the -\*- C++ -\*- to indicate that it is a C++ file and also details about the code's use must be commented properly at the beginning. The macros must be in caps and separated by underscores. LLVM tries to use as minimal "include" as possible to improve compilation time and does not use braced initializers for constructor calls. It is advised to use auto for readability. More of the design decisions can be found [here](https://llvm.org/docs/CodingStandards.html).

Some of the important patterns followed by Clang are as follows:
- **Modularity**
	It uses proper namespaces to merge the parts of code together and also divides the front end into many libraries that make sure the code is readable and easy to debug. 

- **Paradigms Used**
	It uses the procedural paradigm and object oriented paradigm equally. The functions have been divided into utility, compiler logic related and operators. As part of object oriented programming, the inheritance and multiple inheritance and virtual methods have been used as cited above. Apart from these paradigms, the generic and functional paradigms also have been used in some parts of the code. The generic paradigms mainly used the standard template library and some generic types defined explicitly. The lambda expressions can be found in some parts of code.

-  **Factory Design**
	A separate abstract class with virtual constructors are defined that creates and objects and the sub classes can instantiate them later. This pattern is called factory design which is used in LLVM/Clang code base. Apart from this other software design patterns like observer and visitor are also used in code base.

- **RTTI avoidance**
	It stands for Run Time Type Inference which is strongly avoided in LLVM/Clang code base to avoid confusions. Even they mention the open source developers contributing to not to pull requests with RTTI involved.

### Iterators and Data structures
```
std::unique_ptr<clang::ASTConsumer> newASTConsumer() {
if (ASTList)
return clang::CreateASTDeclNodeLister();
}
```
This is a part of function definition. It returns a unique_ptr which is a smart pointer. The unique pointer means that it owns and manages a object until this pointer goes out of scope. This makes sure that no other object can be made to point by this pointer. C++ 14 has improved on smart pointers.
```
class SmallSet {
SmallVector<T, N> Vector;
std::set<T, C> Set;
union {
SetIterTy SetIter;
VecIterTy VecIter;
};
};
```
This class uses the set data structure provided by standard template library. It also uses union which is not recommended by Stroustrup yet is used in this code base. Similar to this class, there are other classes like SmallVector, DenseMap, StringMap, BitVectors, SparseSet etc. defined in the code base. Their definitions use the STL and add some additional functionalities.

# Conclusion
The LLVM/CLang code base is pretty huge and I have tried to cover most of the cool features of C++ which was used in it. We have observed that various OOP concepts like polymorphism, inheritance, smart pointers, STL, auto keywords, lambda expressions etc have been used in the code base. Most of the code snippets used in this report have been taken from the git [repository](https://github.com/llvm/llvm-project/) of LLVM/Clang.

[Here](https://github.com/manojgayala/POPL-2/blob/main/cs19btech11011.md) is the github link to my repository where you can find this markdown file.
